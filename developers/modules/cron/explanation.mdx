---
title: "Understanding Cron"
description: "Detailed explanation of how the Cron module works and why it's designed this way"
---

This document provides a technical explanation of the Cron module architecture, concepts, and design choices.

## What is the Cron Module?

The Cron module enables on-chain time-based automation by maintaining a registry of schedules and executing them at the appropriate block heights. Traditional blockchain applications require external triggers for time-sensitive operations, which creates several challenges:

- **Reliability concerns**: External automation services might fail
- **Centralization risks**: Reliance on third-party services
- **Coordination problems**: Multiple actors might attempt the same operation
- **Timing precision**: Exact execution timing is difficult to ensure

The Cron module solves these problems by moving time-based automation directly onto the blockchain, ensuring deterministic, reliable, and decentralized execution of scheduled operations.

## How does the Cron module work?

The Cron module enables on-chain time-based automation through several components working together:

### Schedule Registration

When a smart contract creates a schedule, it specifies:
- A unique name for identification
- The execution period (in blocks)
- One or more messages to execute
- Gas limits for each message

The module stores this schedule in its state, associating it with the creator's address.

### Execution Mechanism

The module hooks into Neutron's block production process to check for schedules due for execution:

1. During each block's `EndBlock` phase, the module queries for all schedules where:
   ```
   current_block_height â‰¥ (last_execution_height + period)
   ```

2. For each schedule that meets this condition, the module:
   - Constructs the message(s) specified in the schedule
   - Executes them with the predefined gas limits
   - Updates the schedule's `last_execution_height` to the current block height

3. If a schedule has a non-zero period, it remains in the state for future executions. If the period is zero (one-time execution), it is removed after execution.

### Schedule Structure

A schedule is the core data structure in the Cron module that represents a time-based task:

| Property | Description |
|----------|-------------|
| `name` | Unique identifier for the schedule |
| `owner` | Address that created and controls the schedule |
| `period` | Number of blocks between executions |
| `msgs` | Messages to execute when the schedule is triggered |
| `boundary` | Optional starting block height |
| `last_execute_height` | Block height when the schedule was last executed |

Schedules can be:
- **Periodic**: Executing at regular intervals (when `period > 0`)
- **One-time**: Executing once at a specified future block (when `period = 0`)

### Schedule Ownership and Management

Each schedule is owned by the address that created it, which is typically a smart contract. Only the owner can:
- Update the schedule's parameters (period, messages, etc.)
- Remove the schedule explicitly

This ownership model ensures that schedules are properly managed and can't be tampered with by unauthorized parties.

## Security Model

The Cron module implements several mechanisms to ensure security and prevent abuse:

### Gas Limitation

To prevent DoS attacks and excessive resource consumption:
- Each schedule specifies gas limits for its messages
- There's a network-wide `max_gas_per_block` parameter that limits the total gas used by scheduled tasks in a single block
- If executing all due schedules would exceed this limit, some are delayed until subsequent blocks

### Message Validation

The module validates messages before execution:
- Messages must be properly formatted and valid according to their respective handlers
- Invalid messages are rejected during schedule creation
- Execution failures are logged but don't stop other schedules from executing

### Protected State Access

The module's state can only be modified through its exposed message handlers:
- Direct state manipulation is not possible
- All state changes follow proper authorization checks

## Design Decisions

### Why use block heights instead of timestamps?

Block heights provide several advantages over timestamps for scheduling:

1. **Determinism**: Block heights advance in a predictable manner, while block times can vary
2. **Simplicity**: Working with integer increments is simpler than datetime calculations
3. **Consensus**: All validators agree on the current block height without ambiguity

However, this approach means that schedules are sensitive to changes in average block time. If block times slow down or speed up significantly, the real-world timing of scheduled executions will be affected.

### Why allow multiple messages per schedule?

Supporting multiple messages in a single schedule enables more complex workflows:

1. **Atomicity**: Related operations can be grouped together
2. **Efficiency**: Reduces the number of separate schedules needed
3. **Sequence**: Actions can be executed in a specific order

This approach simplifies common patterns like "update state, then transfer funds" or "check condition, then execute action."

### Why use a pre-paid gas model?

The pre-paid gas model where creators specify gas limits upfront:

1. **Prevents abuse**: Ensures scheduled tasks can't consume unlimited resources
2. **Provides predictability**: Network operators can estimate maximum gas usage
3. **Encourages efficiency**: Developers must consider the gas requirements of their scheduled tasks

## Implementation Considerations

### Schedule Execution Order

When multiple schedules are due for execution in the same block, they are processed in a deterministic order based on:
1. First by `last_execution_height` (older executions first)
2. Then by schedule creation time (older schedules first)
3. Finally by name (alphabetical order)

This ordering ensures fairness and prevents starvation of older schedules.

### Failure Handling

If a scheduled message fails during execution:
1. The failure is logged
2. The schedule's `last_execution_height` is still updated
3. The schedule continues to be processed in future blocks if it's periodic

This approach ensures that temporary failures don't permanently break scheduling logic.

### Schedule Limits

The module implements reasonable limits to prevent abuse:
- Maximum name length for schedules
- Maximum number of messages per schedule
- Maximum size for each message
- Minimum period (to prevent excessive execution frequency)

## Module Parameters

Network-wide parameters can be adjusted through governance:

| Parameter | Description | Default |
|-----------|-------------|---------|
| `max_gas_per_block` | Maximum gas for scheduled tasks per block | 6,000,000 |
| `max_msg_size` | Maximum size for scheduled messages | 10,240 bytes |
| `max_msgs_per_schedule` | Maximum number of messages in a schedule | 10 |
| `max_name_length` | Maximum length of schedule names | 64 characters |
| `min_period` | Minimum blocks between executions | 5 blocks |

## Best Practices for Integration

### Gas Estimation

When creating schedules, it's important to:
- Estimate gas requirements conservatively
- Include a buffer for potential future changes
- Test different scenarios to find optimal limits

```rust
// Example of setting gas with a safety buffer
let estimated_gas = 50_000;
let gas_buffer = 20_000;
let gas_limit = estimated_gas + gas_buffer;
```

### Error Handling

Since schedules might fail for various reasons, contracts should:
- Make scheduled operations idempotent (safe to execute multiple times)
- Include validation within scheduled messages
- Implement fallback mechanisms for critical operations

### Schedule Organization

For complex applications:
- Use a consistent naming scheme for schedules
- Create separate schedules for independent operations
- Consider schedule dependencies in your design

## Typical Use Cases

The Cron module supports a wide range of time-based tasks:

### Financial Operations

- **Interest accrual**: Regular updates to lending/borrowing rates
- **Vesting schedules**: Gradual token unlocking
- **Reward distribution**: Periodic rewards to stakers or liquidity providers

### Protocol Maintenance

- **State cleanup**: Removing expired or obsolete data
- **Parameter updates**: Scheduled changes to protocol parameters
- **Rebalancing**: Periodic adjustments to maintain target ratios

### Time-Sensitive Events

- **Auction endings**: Automatic settlement at deadline
- **Governance execution**: Implementing approved proposals after timelock
- **Emergency procedures**: Scheduled failsafes or circuit breakers

## Limitations and Future Improvements

### Current Limitations

- **Block Height Dependency**: Schedule timing is sensitive to block time variations
- **Gas Estimation**: Developers must accurately estimate gas requirements
- **No Conditional Execution**: Schedules execute regardless of external conditions

### Planned Enhancements

- **Conditional Schedules**: Allow schedules to execute only if certain conditions are met
- **Dynamic Gas Adjustment**: Automatically adjust gas based on previous executions
- **Schedule Dependencies**: Define explicit dependencies between schedules
- **Improved Monitoring**: Better tools for tracking and managing schedules 