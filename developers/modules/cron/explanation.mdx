---
title: "Understanding Cron"
description: "Detailed explanation of how the Cron module works and why it's designed this way"
---

# Explanation

This document provides a technical explanation of the Cron module architecture, concepts, and design choices.

## How does the Cron module work?

The Cron module enables on-chain time-based automation by maintaining a registry of schedules and executing them at the appropriate block heights. Here's a detailed look at its operation:

### Schedule Registration

When a smart contract creates a schedule, it specifies:
- A unique name for identification
- The execution period (in blocks)
- One or more messages to execute
- Gas limits for each message

The module stores this schedule in its state, associating it with the creator's address.

### Execution Mechanism

The module hooks into Neutron's block production process to check for schedules due for execution:

1. During each block's `EndBlock` phase, the module queries for all schedules where:
   ```
   current_block_height â‰¥ (last_execution_height + period)
   ```

2. For each schedule that meets this condition, the module:
   - Constructs the message(s) specified in the schedule
   - Executes them with the predefined gas limits
   - Updates the schedule's `last_execution_height` to the current block height

3. If a schedule has a non-zero period, it remains in the state for future executions. If the period is zero (one-time execution), it is removed after execution.

### Block-Based Scheduling

The module primarily uses block heights for scheduling, which offers several advantages:
- **Determinism**: Block heights are deterministic and immutable
- **Simplicity**: No need for complex time calculations or timezone handling
- **Reliability**: Not affected by block time variations

### Schedule Ownership and Management

Each schedule is owned by the address that created it, which is typically a smart contract. Only the owner can:
- Update the schedule's parameters (period, messages, etc.)
- Remove the schedule explicitly

This ownership model ensures that schedules are properly managed and can't be tampered with by unauthorized parties.

## Security Model

The Cron module implements several mechanisms to ensure security and prevent abuse:

### Gas Limitation

To prevent DoS attacks and excessive resource consumption:
- Each schedule specifies gas limits for its messages
- There's a network-wide `max_gas_per_block` parameter that limits the total gas used by scheduled tasks in a single block
- If executing all due schedules would exceed this limit, some are delayed until subsequent blocks

### Message Validation

The module validates messages before execution:
- Messages must be properly formatted and valid according to their respective handlers
- Invalid messages are rejected during schedule creation
- Execution failures are logged but don't stop other schedules from executing

### Protected State Access

The module's state can only be modified through its exposed message handlers:
- Direct state manipulation is not possible
- All state changes follow proper authorization checks

## Design Decisions

### Why use block heights instead of timestamps?

Block heights provide several advantages over timestamps for scheduling:

1. **Determinism**: Block heights advance in a predictable manner, while block times can vary
2. **Simplicity**: Working with integer increments is simpler than datetime calculations
3. **Consensus**: All validators agree on the current block height without ambiguity

However, this approach means that schedules are sensitive to changes in average block time. If block times slow down or speed up significantly, the real-world timing of scheduled executions will be affected.

### Why allow multiple messages per schedule?

Supporting multiple messages in a single schedule enables more complex workflows:

1. **Atomicity**: Related operations can be grouped together
2. **Efficiency**: Reduces the number of separate schedules needed
3. **Sequence**: Actions can be executed in a specific order

This approach simplifies common patterns like "update state, then transfer funds" or "check condition, then execute action."

### Why use a pre-paid gas model?

The pre-paid gas model where creators specify gas limits upfront:

1. **Prevents abuse**: Ensures scheduled tasks can't consume unlimited resources
2. **Provides predictability**: Network operators can estimate maximum gas usage
3. **Encourages efficiency**: Developers must consider the gas requirements of their scheduled tasks

## Implementation Considerations

### Schedule Execution Order

When multiple schedules are due for execution in the same block, they are processed in a deterministic order based on:
1. First by `last_execution_height` (older executions first)
2. Then by schedule creation time (older schedules first)
3. Finally by name (alphabetical order)

This ordering ensures fairness and prevents starvation of older schedules.

### Failure Handling

If a scheduled message fails during execution:
1. The failure is logged
2. The schedule's `last_execution_height` is still updated
3. The schedule continues to be processed in future blocks if it's periodic

This approach ensures that temporary failures don't permanently break scheduling logic.

### Schedule Limits

The module implements reasonable limits to prevent abuse:
- Maximum name length for schedules
- Maximum number of messages per schedule
- Maximum size for each message
- Minimum period (to prevent excessive execution frequency)

## Best Practices for Integration

### Gas Estimation

When creating schedules, it's important to:
- Estimate gas requirements conservatively
- Include a buffer for potential future changes
- Test different scenarios to find optimal limits

```rust
// Example of setting gas with a safety buffer
let estimated_gas = 50_000;
let gas_buffer = 20_000;
let gas_limit = estimated_gas + gas_buffer;
```

### Error Handling

Since schedules might fail for various reasons, contracts should:
- Make scheduled operations idempotent (safe to execute multiple times)
- Include validation within scheduled messages
- Implement fallback mechanisms for critical operations

### Schedule Organization

For complex applications:
- Use a consistent naming scheme for schedules
- Create separate schedules for independent operations
- Consider schedule dependencies in your design

## Limitations and Future Improvements

### Current Limitations

- **Block Height Dependency**: Schedule timing is sensitive to block time variations
- **Gas Estimation**: Developers must accurately estimate gas requirements
- **No Conditional Execution**: Schedules execute regardless of external conditions

### Planned Enhancements

- **Conditional Schedules**: Allow schedules to execute only if certain conditions are met
- **Dynamic Gas Adjustment**: Automatically adjust gas based on previous executions
- **Schedule Dependencies**: Define explicit dependencies between schedules
- **Improved Monitoring**: Better tools for tracking and managing schedules 